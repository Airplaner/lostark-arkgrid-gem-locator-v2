# Introduction

## System Overview
### 코어 (Core)

코어는 젬을 장착하고 효과를 얻을 수 있는 장비이다. 하나의 코어에는 최대 4개의 젬을 장착할 수 있으며, 장착된 젬의 **활성화 포인트**의 합에 따라 **전투력 계수**를 얻는다. 코어는 젬을 장착하기 위한 제약 조건인 **공급 의지력**을 가지고 있으며, 장착하고자 하는 젬들의 **요구 의지력**의 합 이내에서만 젬들을 장착할 수 있다.

아래 표는 대표적인 코어 계수의 예시이며, 실제 코어마다 계수는 다를 수 있다.

| 활성화 포인트 (p)      | 전투력 계수  |
|----------------------|------------|
| p < 10               | 1.0000     |
| 10–13                | 1.0150     |
| 14–16                | 1.0400     |
| 17                   | 1.0750     |
| 18                   | 1.0767     |
| 19                   | 1.0783     |
| 20                   | 1.0800     |


### 젬 (Gem)

젬은 아래와 같은 3가지 속성을 가지고 있다.

1. 요구 의지력. 코어에 장착하기 위해 필요한 제약 조건이며, 3이상 9이하의 정수이다.

2. 활성화 포인트. 장착된 코어에게 합산되는 값으로 1이상 5이하의 정수이다. 따라서 한 개의 코어는 최대 20의 활성화 포인트를 얻을 수 있다.

3. 공용 옵션. 옵션은 옵션 종류와 활성화 레벨로 이루어져있다. 옵션 종류로는 공격력, 추가 피해, 보스 피해가 있으며 레벨은 1이상 5이하의 정수이다. 하나의 젬은 2개의 공용 옵션을 가지고 있다.

### 속성 (Attribute)
아크 그리드 시스템은 질서와 혼돈 두 가지의 속성으로 나뉘며, 플레이어는 최대 3개의 질서 코어와 3개의 혼돈 코어를 사용할 수 있다. 모든 젬들은 하나의 속성에 속해있으며, 예를 들어 질서의 젬은 질서 코어에만 장착할 수 있다. 다만 젬 옵션 레벨은 속성과 무관하게 모두 합하여 전투력에 계산된다.

## Combat Power Formula
$$
\text{아크 그리드 전투력} =
\left( \prod_{i=1}^{6} C_i(P_i) \right)
\cdot
\frac{\left( 10000 + \left\lfloor \frac{A}{120} \times 400 \right\rfloor \right)}{10000}
\cdot
\frac{\left( 10000 + \left\lfloor \frac{D}{120} \times 700 \right\rfloor \right)}{10000}
\cdot
\frac{\left( 10000 + \left\lfloor \frac{B}{120} \times 1000 \right\rfloor \right)}{10000}
$$

코어에 장착된 젬들의 활성화 포인트 합 $p \in \mathbb{Z}_{\ge 0}$ 에 대해,
코어의 전투력 계수 $C_i(p)$ 는 다음과 같이 정의된다.

$$
C_i(p) =
\begin{cases}
1.0000 & p < 10 \\
1.0150 & 10 \le p < 14 \\
1.0400 & 14 \le p < 17 \\
1.0750 & p = 17 \\
1.0767 & p = 18 \\
1.0783 & p = 19 \\
1.0800 & p = 20 \\
\end{cases}
$$

- $P_i$ 는 $i$번째 코어에 장착된 활성화 포인트의 합이다.
- $C_i(P_i)$ 는 $P_i$에 의해 결정되는 step-wise 계수이며 각 코어는 자신만의 계수를 가진다.
- $A$ 는 모든 장착된 젬들의 **공격력** 옵션 레벨의 합이다.
- $D$ 는 모든 장착된 젬들의 **추가 피해** 옵션 레벨의 합이다.
- $B$ 는 모든 장착된 젬들의 **보스 피해** 옵션 레벨의 합이다.

## Key Observations

일반적으로 코어들은 17 포인트에서 높은 전투력 계수를 제공하기 때문에 이를 최우선적으로 달성하게 되며, 이후에는 추가적인 코어 포인트를 획득하거나 더 좋은 옵션을 가진 젬을 선택할지 사이에서 경쟁하게 된다.

## Problem Definition and Constraints
일반적인 사용자와 실제 게임 내의 제약을 가정하여 속성별로 3개의 코어와 50개의 젬, 따라서 전체 6개의 코어와 100개의 젬을 소유한 것으로 문제를 정의하였다.


## Explored Approaches
### 1. Naive DFS (Depth First Search)
각 질서 및 혼돈 코어의 12개의 젬 슬롯에 대한 경우의 수를 계산하면 아래와 같다.
$$
{50\choose 12} \cdot {50\choose 12} = 1.4\times10^{23}
$$
젬이 20개 내외로 적을 때는 성공적이었으나, 젬의 수가 많아지는 경우에는 유한 시간 내에 불가능하였다.

### 2. Linear Optimization Attempt (Google OR-Tools)

선형 최적화나 CP-SAT 같은 범용 최적화 도구를 사용할 수 없었던 이유는 다음과 같다.

**비선형 목적 함수**: 전투력 공식은 6개 코어 계수와 3개 옵션 계수를 곱하는 형태로,
선형 최적화가 요구하는 선형 결합 형태가 아니다.

**Step-wise 함수의 곱셈**: 각 코어의 활성화 포인트에 따른 계수 $C(P)$는 불연속적인
계단 함수이며, 이를 6개 곱한 뒤 다시 옵션 계수들과 곱해야 한다. 개별 piecewise
함수는 모델링 가능하나, 이들의 곱셈 관계는 Mixed Integer Non-linear Programming
(MINLP) 문제가 되어 일반적인 OR-Tools의 범위를 벗어난다.

**전역 의존성**: 공용 옵션(A, D, B)은 모든 코어에 장착된 젬들의 레벨 합으로
계산되므로, 한 코어의 젬 선택이 다른 모든 코어의 전투력 기여도에 영향을 준다.
이러한 강한 결합은 문제를 분해하기 어렵게 만든다.

이러한 이유로 정확한 최적화 도구 대신 휴리스틱 기반 접근법을 선택하였다.

### 3. Divide-and-Conquer with Bounded Backtracking
문제를 질서와 혼돈 각 속성별로 해결한 후에 합쳐서 전역 최적해를 구하였다.


#### Phase 1. 코어마다 장착 가능한 젬의 조합 계산

각 코어마다 장착 가능한 젬들의 조합을 모두 계산한다. 이론상 코어마다 장착 가능한 조합의 수는 ${50\choose 4} = 230,300$개로 짧은 시간 내에 계산이 가능하였다. 하나의 코어에 젬이 장착된 상태를 $GemSet$ 이라고 하자.

각 $GemSet$에 대해 전체 전투력에 기여할 수 있는 **전투력 계수의 범위**를 계산한다.
코어 활성화 포인트로 얻을 수 있는 계수는 결정적이나(해당 $GemSet$의 포인트 합에 의해 확정),
공용 옵션으로 얻을 수 있는 계수는 다른 코어들의 선택에 의존한다.

**공용 옵션의 한계 효용 체감**: 공용 옵션 레벨은 모든 젬에서 합산된 후 floor 함수로
계산되므로, 전체 레벨 합이 높을수록 추가 레벨의 기여도가 감소한다.

**예시**: 활성화 포인트 17, 공격력 옵션 레벨의 합이 3인 $GemSet$을 고려하자.
- 코어 계수 기여: $C(17) = 1.0750$ (고정)
- 공격력 계수 기여 (최대): 다른 모든 코어의 공격력이 0일 때
  $$\frac{10000 + \lfloor \frac{3}{120} \times 400 \rfloor}{10000} = 1.0010$$
- 공격력 계수 기여 (최소): 다른 코어들의 공격력 합이 117일 때
  $$\frac{10000 + \lfloor \frac{120}{120} \times 400 \rfloor}{10000} \div \frac{10000 + \lfloor \frac{117}{120} \times 400 \rfloor}{10000} \approx 1.00096$$

이러한 범위 계산을 통해 각 $GemSet$의 기여도 범위를 추정하였다.

#### Phase 2. 각 속성별 가능한 조합 계산

모든 $GemSet$을 최대 기여도 기준 내림차순 정렬 후, 3중 루프로 $GemSetPack$을 구성한다.
다음 조건으로 탐색을 가지치기한다:

1. **중복 젬 검사**: 각 젬의 인덱스를 bitmask로 표현하여 O(1) 시간에 검사
2. **상한 기반 가지치기**: 현재 부분 해에 남은 선택지의 최대 기여도를 곱했을 때
   알려진 최적해를 초과할 가능성이 없으면 해당 분기 전체를 제거

**복잡도 분석**:
- 이론상: $\binom{50}{4}^3 \approx 1.2 \times 10^{16}$
- 실제: 상한 가지치기로 대부분의 조합이 초기에 제거됨
  - 예: 첫 번째 $GemSet$ 선택 후 두 번째 선택지의 90% 이상이 pruning됨

또한 각 속성(질서/혼돈)의 계산은 독립적이므로 2개의 Web Worker로 병렬화하여 속도를 극대화하였다.

#### Phase 3. 각 속성별 가능한 조합의 중복 제거 및 최적해 계산

하나의 속성에 대해 3개의 $GemSet$이 선택된 것을 $GemSetPack$이라고 하자. 각각의 속성에서 $GemSetPack$을 하나씩 선택하면 정확한 전투력을 계산할 수 있다. 그러나 각 $GemSetPack$에서 사용된 젬의 종류는 이 계산에 영향을 주지 않는다. 따라서 아래 조건이 동일한 중복들을 제거하여 계산 횟수를 줄인다.

**중복 제거**:
- 달성한 코어 전투력 계수의 곱: $\prod_{i=1}^{3} C_i(P_i)$
- 공용 옵션 레벨의 합: $(A, D, B)$

위 두 값이 동일한 $GemSetPack$은 중복되기에 제외한다.

**최종 계산**:
- 질서 속성의 $GemSetPack$ 집합: $\mathcal{O}$ (크기 $M$)
- 혼돈 속성의 $GemSetPack$ 집합: $\mathcal{C}$ (크기 $N$)
- 전체 전투력: 모든 $(o, c) \in \mathcal{O} \times \mathcal{C}$ 조합에 대해 계산
- 복잡도: $O(M \times N)$

각 조합에 대해 전체 전투력 공식을 적용하여 전역 최적해를 구한다.

## Limitations and Future Work

### 현재 방법의 한계
1. **확장성**: 젬 개수가 추가로 증가 시 Phase 2의 복잡도 급증
2. **동적 환경**: 젬 추가/제거 시 전체 재계산 필요

### 향후 개선 방향
1. **Pareto Filtering**: 지배당하는 해(dominated solutions) 제거로 탐색 공간 추가 축소
2. **메타휴리스틱 비교**: Simulated Annealing, Genetic Algorithm 등과 성능 비교
